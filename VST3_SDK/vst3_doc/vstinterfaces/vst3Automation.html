<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VST 3 Interfaces: Parameters and Automation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VST 3 Interfaces
   &#160;<span id="projectnumber">VST 3.7</span>
   </div>
   <div id="projectbrief">SDK for developing VST plug-in</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('vst3Automation.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Parameters and Automation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#vst3ParameterIntro">Parameters</a><ul><li class="level2"><a href="#Representationofparametervalues">Representation of parameter values</a><ul><li class="level3"><a href="#parameterstyle">Parameter styles / &#39;Step Count&#39;</a></li>
</ul>
</li>
<li class="level2"><a href="#Conversionofnormalizedvalues">Conversion of normalized values</a></li>
</ul>
</li>
<li class="level1"><a href="#vst3AutomationIntro">Automation</a><ul><li class="level2"><a href="#problems">Problems</a></li>
<li class="level2"><a href="#vst3automationRecording">Automation Recording</a><ul><li class="level3"><a href="#sliderknobs">Sliders &amp; Knobs</a></li>
<li class="level3"><a href="#buttonradiopopup">Buttons / Radio Groups / Pop-up Menus</a></li>
<li class="level3"><a href="#textinput">Text Input</a></li>
</ul>
</li>
<li class="level2"><a href="#vst3automationPlayback">Automation Playback</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Description of how parameters are defined and used in <a class="elRef" doxygen="/Builddata/re/255370135/b/VST_SDK/VST3_SDK/vst3_doc/vstsdk/vstsdk.tag:../vstsdk/" href="../vstsdk/namespaceVST3.html">VST3</a></p>
<h1><a class="anchor" id="vst3ParameterIntro"></a>
Parameters</h1>
<p>A plug-in requires parameters in order to control its DSP algorithm, for example, a Frequency parameter for a filter. The plug-in can export these parameters in order to make them visible to the host and allow the host to control/change/automate/remote/visualize them. Some parameters can be defined for private use only (not visible to the user) or as read-only, such as parameters associated to VU Meters. <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#ab6ffbb8e3bf6f4829ab1c9c23fe935a1" title="Returns the number of parameters exported.">Steinberg::Vst::IEditController::getParameterCount</a> allows the host to identify the number of parameters that are exported by the plug-in.</p>
<p><br />
The plug-in must assign a unique 32-bit identifier to each exported parameter.</p><ul>
<li>Up to 2^31 parameters can be exported [0, 2147483648] (the range [2147483649, 429496729] is reserved for host application).<br />
Please note that it is not allowed to change this assignment at any time. In particular, a plug-in must not perform any reconfigurations that lead to a different set of automatable parameters. The only allowed variation is the adding or removing of parameters in a future plug-in version. However, keep in mind that automation data can get lost when parameters are removed. <br />
<br />
</li>
<li>Usually, the host is unaware of a parameter's semantics. However, there are a few important exceptions that the controller must announce using the <a class="el" href="structSteinberg_1_1Vst_1_1ParameterInfo.html#a8ffba1d4311e48ae488bc118f20d7edb" title="ParameterFlags (see below)">Steinberg::Vst::ParameterInfo::flags</a>: <br />
<br />
<ul>
<li><b>kCanAutomate:</b> This means that this parameter can be automated by the host using its automation track <br />
<br />
</li>
<li><b>kIsBypass:</b> If the plug-in performs bypass processing itself, it must export the corresponding parameter and flag it with kIsBypass. It is highly recommended that this bypass parameter is provided by effect plug-in. If the plug-in does not export a bypass parameter, the host can perform bypass processing and the plug-in process call will be discontinued. Only one bypass parameter is allowed. The plug-in should save the state of this bypass parameter like other parameters (when getState and setState are used). It is highly recommended to export a bypass parameter for an effect plug-in. <br />
<br />
</li>
<li><b>kIsReadOnly:</b> This means that this parameter cannot be changed from outside the plug-in, this requires that kCanAutomate is NOT set. <br />
<br />
</li>
<li><b>kIsWrapAround:</b> When a UI control created by the host for this parameter attempts to set its value out of the limits, this UI control will make a wrap around (useful for parameters like 360 deg rotation). [SDK 3.0.2] <br />
<br />
</li>
<li><b>kIsList:</b> This means that the host will display this parameter as list in a generic editor or automation editing. [SDK 3.1.0] <br />
<br />
</li>
<li><b>kIsHidden:</b> This means that this parameter will NOT be displayed and cannot be changed from outside the plug-in. This requires that kCanAutomate is NOT set and kIsReadOnly is set. [SDK 3.7.0] <br />
<br />
</li>
<li><b>kIsProgramChange:</b> If the plug-in supports program lists (see <a class="el" href="vst3Units.html">VST 3 Units</a>, <a class="el" href="vst3Presets.html#vst3ProgramLists">Program Lists</a>), each 'unit' of the plug-in needs to export a program selector parameter. Such a parameter is not allowed to be automated when the affected parameters are flagged as automatable as well. A host can display program parameters at dedicated locations of its GUI. <br />
<br />
</li>
</ul>
</li>
<li>The controller must support the conversion to a string for any exported parameter. The conversion method <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#aab2f0b853e75361d331b667e7893962e" title="Gets for a given paramID and normalized value its associated string representation.">Steinberg::Vst::IEditController::getParamStringByValue</a> must provide a result for any possible normalized parameter value. <br />
<br />
</li>
<li>Parameter values are always transmitted in a normalized floating point (64bit double) representation [0.0, 1.0].</li>
</ul>
<h2><a class="anchor" id="Representationofparametervalues"></a>
Representation of parameter values</h2>
<p>A plug-in parameter usually has more than one representation. The GUI of a plug-in can display something that appears to be a single parameter, but might control multiple processing parameters at the same time. Or the GUI representation displays a scale-transformed representation of a DSP-parameter. <br />
<br />
 Somewhere on the way from the GUI to the DSP algorithm this transformation has to be performed. The host does not need information about DSP parameters, but it is responsible for reporting parameter changes to the processor. According to this, the processor is the only place where a transformation can happen and all parameters always have to match the GUI representation. <br />
<br />
 Does this fit into the idea of separating GUI and processing? No problem so far</p><ul>
<li>it is a separation of duties, nothing more. The processor component and the controller component have to work on the same internal plug-in model. The controller knows how this model has to be presented in GUI. The processor knows how the model has to be translated into DSP parameters. <br />
The VST 3 interfaces suggest a normalized value representation for a part of this model (the part that is exported as parameters). This means every value has to be inside the range from 0.0 to 1.0.</li>
</ul>
<h3><a class="anchor" id="parameterstyle"></a>
Parameter styles / 'Step Count'</h3>
<p>Although values are transmitted in a normalized format, the host needs to know some details of the parameter's displayed GUI representation. When editing automation data, for example, the host must know the nature of a parameter expressed in its 'step count' (see <a class="el" href="structSteinberg_1_1Vst_1_1ParameterInfo.html#ac1efeff62e4ba9aea101c3327e0b5c4d">Steinberg::Vst::ParameterInfo::stepCount</a>). <br />
<br />
 <b> Step count semantics </b>:</p><ul>
<li>0 : A continuous parameter. Any normalized value has an exact mapping (0 = there are no steps between the values)</li>
<li>1 : A discrete parameter with 2 states like [on/off] [yes/no] etc. (1 = there is one step between these states)</li>
<li>2 : A discrete parameter with 3 states [0,1,2] or [3,5,7] (2 = there are two steps between these states)</li>
<li>3 : etc...</li>
</ul>
<h2><a class="anchor" id="Conversionofnormalizedvalues"></a>
Conversion of normalized values</h2>
<p>The controller and the processor have to work with normalized parameter values.</p><ul>
<li>Step count 0 : Continuous parameters simply need to be mapped accordingly</li>
<li>Step count n : Discrete parameters need a little bit more care<ul>
<li>Discrete Value =&gt; Normalize: <div class="fragment"><div class="line"><span class="keywordtype">double</span> normalized = discreteValue / (double) stepCount; </div></div><!-- fragment --></li>
<li>Normalize =&gt; Discrete Value (Denormalize) : <div class="fragment"><div class="line"><span class="keywordtype">int</span> discreteValue = min (stepCount, normalized * (stepCount + 1));</div></div><!-- fragment --></li>
</ul>
</li>
</ul>
<p><br />
<b> Example: </b> Step Count 3 </p><div class="image">
<img src="valuerange.jpg" alt="valuerange.jpg"/>
</div>
<p> <br />
<br />
</p>
<h1><a class="anchor" id="vst3AutomationIntro"></a>
Automation</h1>
<p>A host that supports parameter automation is dependent on a proper cooperation of the component owning these parameters. One intention in the design of the VST 3 interfaces was to reduce the amount of possible mistakes for an implementation. The separation of processor and controller enforces that all parameter changes have to be handled by the host in a defined way. Additionally, this way allows the host to store the changes as automation data. Nevertheless, there are some more things to consider:</p>
<dl class="section user"><dt></dt><dd><b> No automated parameter must influence another automated parameter! </b></dd></dl>
<p>The prime example for this is the automation of preset changes. A preset change can lead to the change of all 'normal' parameters. So if automation data already has been recorded for these parameters and the preset change is recorded as well: who wins? This question cannot be answered and the problem can only be resolved by avoiding it. This is why automation of preset changes is not allowed by default.</p>
<h2><a class="anchor" id="problems"></a>
Problems</h2>
<p>A fix value range from 0.0 to 1.0 simplifies the handling of parameters in some ways, but there are problems: <br />
</p><ul>
<li><b> Non-linear scaling </b> <br />
If the DSP representation of a value does not scale in a linear way to the exported normalized representation (which can happen when a decibel scale is used, for example), the edit controller must provide a conversion to a plain representation. This allows the host to move automation data (being in GUI representation) and keep the original value relations intact. (<a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a849747dc98909312b4cdbdeea82dbae0" title="Returns for a given paramID and a normalized value its plain representation (for example -6 for -6dB ...">Steinberg::Vst::IEditController::normalizedParamToPlain</a> / <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#ae9706616ae6d938bbf102954f8f2f110" title="Returns for a given paramID and a plain value its normalized value.">Steinberg::Vst::IEditController::plainParamToNormalized</a>). <br />
 <br />
</li>
<li><b> Changes in future plug-in versions </b> <br />
Take a discrete parameter, for example, that controls an option of three choices. If the host stores normalized values as automation data and a new version of a plug-in invented a fourth choice, the automation data will be invalid now. So either the host has to store denormalized values as automation or it must recalculate the automation data accordingly. <br />
 <br />
</li>
</ul>
<h2><a class="anchor" id="vst3automationRecording"></a>
Automation Recording</h2>
<p>Automation recording is performed by the host. In doing so, it is essential for the host to know the start and the end of a manipulation. Therefore, the plug-in must operate the <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html" title="Host callback interface for an edit controller: Vst::IComponentHandler.">Steinberg::Vst::IComponentHandler</a> interface in the following way and in the UI Thread!: <br />
</p><ul>
<li>The begin of a manipulation must be signaled via <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#a8456ad739430267a12dda11a53fe9223" title="To be called before calling a performEdit (e.g.">Steinberg::Vst::IComponentHandler::beginEdit</a> <br />
<br />
</li>
<li>Changes of parameters are reported via <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93" title="Called between beginEdit and endEdit to inform the handler that a given parameter has a new value.">Steinberg::Vst::IComponentHandler::performEdit</a> <br />
<br />
</li>
<li>The end of a manipulation must be signaled via <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#ae380206486b11f000cad7c0d9b6e877c" title="To be called after calling a performEdit (e.g.">Steinberg::Vst::IComponentHandler::endEdit</a> <br />
<br />
</li>
</ul>
<p>The plug-in must stick to the order of these callbacks. Otherwise, automation recording cannot work correctly. However, the implementation can bring up difficulties. Each type of GUI control and the way it is operated along with the nature of the controlled parameter requires specific considerations. <br />
 To address the most common cases:</p>
<h3><a class="anchor" id="sliderknobs"></a>
Sliders &amp; Knobs</h3>
<p>These kind of controls usually control continuous parameters and they are usually operated with the mouse. This common case is the most simple to handle: On mouse-click-down call beginEdit (followed by performEdit when the control allows a jump), on mouse-drag call performEdit and on mouse-click-up call endEdit. <br />
<br />
Trouble starts with the <b>mouse wheel</b>: There simply is nothing like a defined start or end when the wheel is operated - each wheel event arrives "out of the blue". The only way to enable proper automation recording in this case is the usage of a timer. <br />
</p><ul>
<li>A plug-in implementation should call beginEdit when the first wheel event is handled and start a timer (followed by the first call to performEdit). Further wheel events that arrive inside of the timeout interval are reported with performEdit and the timer is restarted. When the timeout period has passed without further events, endEdit should be called and the timer can be removed. <br />
<br />
</li>
<li>But since it is the host's task to record automation data, one could argue that it should be the host's task to take care of the timer in this case. This is the reason for the following exception to the rule: <br />
<ul>
<li>Mouse wheel events can be reported without beginEdit and endEdit to the host. The host must be prepared to receive a performEdit without a previous call of beginEdit for a parameter and handle the timeout itself.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="buttonradiopopup"></a>
Buttons / Radio Groups / Pop-up Menus</h3>
<p>These kind of controls usually control discrete parameters and simply switch the state of something. A proper handling is to call beginEdit, performEdit and endEdit in a row. The affected parameter has to be exported to the host with the correct step count because discrete parameters are handled differently than continuous parameters in regard to automation. <br />
<br />
Mouse wheel handling usually is not supported for buttons, but sometimes for pop-up menus. Discrete parameters do not require the usage of a timer in order to be recorded correctly. <br />
<br />
So the plug-in should call the 3 functions in a row for each wheel event - again, the other option is to omit beginEdit and endEdit, but in this case make sure to report the discrete nature of the parameter to the host correctly.</p>
<h3><a class="anchor" id="textinput"></a>
Text Input</h3>
<p>For reporting the results of a text input value change, for a continuous or a discrete parameter, always call beginEdit, performEdit and endEdit in a row. <br />
<br />
</p>
<h2><a class="anchor" id="vst3automationPlayback"></a>
Automation Playback</h2>
<p>In VST 3, automation playback is the task of the plug-in and it is the host's task to provide the automation data. The only way for a parameter change to arrive in the processor is the processing call. Receiving parameter changes from the edit controller and playing back automation data is one and the same thing. <br />
<br />
The need to perform all transformations, from the normalized GUI representation to the DSP representation, produces some overhead. Performing sample accurate automation requires even more overhead, because the DSP value must be calculated for each single sample. While this cannot be avoided entirely, it is the choice of the plug-in implementation how much processing time to spent on automation accuracy. The host always transmits value changes in a way that allows a sample accurate reconstruction of the underlying automation curve. The plug-in is responsible for the realization.</p>
<dl class="section user"><dt>GUI playback</dt><dd>The host is responsible for updating the plug-in GUI when automation data is transmitted to the processor. This is realized by frequent calls of <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#aded549c5b0f342a23dee18cc41ece6b8" title="Sets the normalized value to the parameter associated to the paramID.">Steinberg::Vst::IEditController::setParamNormalized</a> in the UI Thread.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classSteinberg_1_1Vst_1_1IParameterChanges.html" title="All parameter changes of a processing block: Vst::IParameterChanges.">Steinberg::Vst::IParameterChanges</a>, <a class="el" href="classSteinberg_1_1Vst_1_1IParamValueQueue.html" title="Queue of changes for a specific parameter: Vst::IParamValueQueue.">Steinberg::Vst::IParamValueQueue</a></dd></dl>
<p><br />
Back to <b><a class="el" href="index.html#vst3Contents">Contents</a></b> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<html>
    <head>
	    <title>Empty</title>
	    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	    <meta name="Author" content="Steinberg">
    </head>
    <body>
    <br/>
    <hr width="100%" size="2" align="left" />
    <div align=right>
        Copyright &copy;2020 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
        All Rights Reserved. This documentation is under this <a href="http://www.steinberg.net/sdklicenses" target="_blank"><u>license</u></a>.
    </div>
</body>
</html>
