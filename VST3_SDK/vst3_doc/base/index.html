<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Interface Technology Basics: VST Module Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Interface Technology Basics
   &#160;<span id="projectnumber">VST 3.7</span>
   </div>
   <div id="projectbrief">SDK for developing VST plug-in</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">VST Module Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#piVstMa">Introduction</a></li>
<li class="level1"><a href="#piInterfaces">Interfaces</a><ul><li class="level2"><a href="#funknown">FUnknown</a></li>
<li class="level2"><a href="#iid">IID/CID</a></li>
<li class="level2"><a href="#direction">Direction</a></li>
<li class="level2"><a href="#version">Versioning and inheritance</a></li>
<li class="level2"><a href="#com">COM Compatibility</a></li>
<li class="level2"><a href="#basic">Basic Interfaces</a></li>
<li class="level2"><a href="#helper">Helper Classes</a></li>
</ul>
</li>
<li class="level1"><a href="#piPlugins">Plug-ins</a><ul><li class="level2"><a href="#module">Module Factory</a></li>
<li class="level2"><a href="#Locations">Locations</a></li>
<li class="level2"><a href="#Categories">Categories</a></li>
<li class="level2"><a href="#IPluginBase">IPluginBase</a></li>
<li class="level2"><a href="#purpose">Purpose-specific interfaces</a></li>
</ul>
</li>
<li class="level1"><a href="#Unicode">Unicode</a><ul><li class="level2"><a href="#plugunicode">Plug-ins for Unicode hosts</a></li>
<li class="level2"><a href="#migrating">Migrating from non-Unicode to Unicode</a></li>
<li class="level2"><a href="#backward">SDK backward compatibility</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="piVstMa"></a>
Introduction</h1>
<p><b>VST-MA</b> is a component model system which is used in all <a href="http://www.steinberg.net" target="_blank">Steinberg</a> host applications as the basic layer for plug-in support as well as for internal application components.<br />
It is object-oriented, cross-platform and (almost) compiler-independent. <br />
The basics are very much like Microsoft(R) COM, so if you are familiar with this technology, understanding VST-MA should be quite easy.</p>
<p><b>VST-MA</b> is provided in C++ only. Interfaces in C++ are expressed as pure virtual class (which is a class with nothing but abstract methods). Unlike COM there is no support for C or other languages yet - simply because there has been no need for this so far. But all <b>VST-MA</b> interfaces can be transformed into different representations in case this should be inevitable some day. <br />
It is currently available for Windows and Mac OS X.</p>
<p>The C++ files belonging to <b>VST-MA</b> are located in the following folders:</p><ul>
<li><a href="../../pluginterfaces/base" target="_blank">pluginterfaces/base</a></li>
<li><a href="../../pluginterfaces/gui" target="_blank">pluginterfaces/gui</a></li>
</ul>
<p><b>Note:</b> The name 'VST Module Architecture' has only little relation to the 'Virtual Studio Technology' itself. <br />
It describes the basic layer for any plug-in category supported in <a href="http://www.steinberg.net" target="_blank">Steinberg</a> hosts. <b>VST-MA</b> existed long before it was used as a base for VST 3 ifself. <br />
<br />
</p>
<h1><a class="anchor" id="piInterfaces"></a>
Interfaces</h1>
<h2><a class="anchor" id="funknown"></a>
FUnknown</h2>
<p><a class="el" href="classSteinberg_1_1FUnknown.html" title="The basic interface of all interfaces.">Steinberg::FUnknown</a> is the basic interface of <b>VST-MA</b>. All other interfaces are directly or indirectly derived from it. <br />
<br />
</p>
<h2><a class="anchor" id="iid"></a>
IID/CID</h2>
<p>Each interface has a unique identifier (IID) of type <a class="el" href="classSteinberg_1_1FUID.html" title="Handling 16 Byte Globally Unique Identifiers.">Steinberg::FUID</a>. It is used to retrieve a new interface from another one (<a class="el" href="classSteinberg_1_1FUnknown.html#a4199134d0669bfa92b7419dac14c01a7" title="Query for a pointer to the specified interface.">Steinberg::FUnknown::queryInterface</a>). It is important to understand the difference between interface identifier and component identifier.<br />
 A component-ID or class-ID (CID) is used to identify a concrete implementation class and is usually passed to a class factory in order to create the corresponding component. <br />
 So a lot of different classes (with different class identifiers) can implement the same interfaces. <br />
 <br />
</p>
<h2><a class="anchor" id="direction"></a>
Direction</h2>
<p>An interface may have a <b>direction</b>, meaning that the interface is expected to be implemented either in the plug-in or in the host. The nature of an interface is documented like this: <br />
 <br />
</p><ul>
<li><b>[host imp] </b>: the host implements the interface</li>
<li><b>[plug imp] </b>: the plug-in implements the interface</li>
</ul>
<p><br />
 When neither of these is specified, the interface can be used in both ways. <br />
<br />
</p>
<h2><a class="anchor" id="version"></a>
Versioning and inheritance</h2>
<p>Unlike C++ classes, interfaces do not use inheritance to express specializations of objects. Inheritance is used for versioning only. One of the strict rules is, that once an interface has been released, it must never change again. Adding new functionality to an interface requires a new version (usually an ordinal number is added to its name in this case).<br />
 A new version inherits the old version(s) of the interface, so the old and the new methods are combined in one interface. This is why specializations need to be modeled as separate interfaces! If a specialized interface were to inherit from the basic interface as well, an implementation class that needs to implement all of these interfaces would inherit the base interface twice, causing the compiler to run into ambiguities. So the specialization relation to a basic interface can only be expressed in the documentation: <br />
 <br />
</p><ul>
<li>ISpecialInterface [<b>extends</b> IBaseInterface] =&gt; means IBaseInterface::queryInterface (ISpecialInterface::iid, ...) can be used to retrieve the derived interface.</li>
</ul>
<p><br />
 You can find some example code here: <a class="el" href="versionInheritance.html">Interface Versions and Inheritance</a> <br />
<br />
</p>
<h2><a class="anchor" id="com"></a>
COM Compatibility</h2>
<p>The first layer of <b>VST-MA</b> is binary-compatible to <b>COM</b>. The Vtable and interface identifier of FUnknown match with the corresponding COM interface IUnknown. The main difference is the organization and creation of components by a host application. <b>VST-MA</b> does not require any Microsoft(R) COM source file. You can find information about <b>COM</b> on pages like: <br />
</p><ul>
<li> <a href="http://www.microsoft.com/Com/resources/comdocs.asp" target="_blank">http://www.microsoft.com/Com/resources/comdocs.asp</a>. <br />
<br />
</li>
</ul>
<h2><a class="anchor" id="basic"></a>
Basic Interfaces</h2>
<ul>
<li><a class="el" href="classSteinberg_1_1FUnknown.html" title="The basic interface of all interfaces.">Steinberg::FUnknown</a></li>
<li><a class="el" href="classSteinberg_1_1IPluginBase.html" title="Basic interface to a plug-in component: IPluginBase.">Steinberg::IPluginBase</a></li>
<li><a class="el" href="classSteinberg_1_1IPluginFactory.html" title="Class factory that any plug-in defines for creating class instances: IPluginFactory.">Steinberg::IPluginFactory</a></li>
</ul>
<p><br />
<br />
</p>
<h2><a class="anchor" id="helper"></a>
Helper Classes</h2>
<ul>
<li><a class="el" href="classSteinberg_1_1FUID.html" title="Handling 16 Byte Globally Unique Identifiers.">Steinberg::FUID</a></li>
<li><a class="el" href="classSteinberg_1_1FUnknownPtr.html" title="FUnknownPtr - automatic interface conversion and smart pointer in one.">Steinberg::FUnknownPtr</a></li>
</ul>
<p><br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="howtoClass.html">How to derive a class from an interface</a> <br />
<br />
</dd></dl>
<h1><a class="anchor" id="piPlugins"></a>
Plug-ins</h1>
<h2><a class="anchor" id="module"></a>
Module Factory</h2>
<p>A module (Windows: Dynamic Link Library, MAC: Mach-O Bundle) contains the implementation of one or more components (e.g. VST 3 effects). A <b>VST-MA</b> module must contain a class factory where meta-data and create-methods for the components are registered. <br />
 The host has access to this factory through the <a class="el" href="classSteinberg_1_1IPluginFactory.html" title="Class factory that any plug-in defines for creating class instances: IPluginFactory.">Steinberg::IPluginFactory</a> interface. This is the anchor point for the module and it is realized as a C-style export function named GetPluginFactory. You can find an export definition file in folder - <a href="../../public.sdk/win/stdplug.def" target="_blank">public.sdk/win/stdplug.def</a> which can be used to export this function. <br />
 GetPluginFactory is declared as follows:</p>
<div class="fragment"><div class="line">IPluginFactory* PLUGIN_API <a class="code" href="group__pluginBase.html#ga843ac97a36dfc717dadaa7192c7e8330">GetPluginFactory</a> ()</div></div><!-- fragment --><p> <br />
</p>
<h2><a class="anchor" id="Locations"></a>
Locations</h2>
<p>Component modules do not require registration like DirectX. The host application expects component modules to be located in predefined folders of the file system. These folders and their subfolders are scanned for <b>VST-MA</b> modules during application startup. Each folder serves a special purpose:</p><ul>
<li>The application's <code>Components</code> subfolder (e.g. "C:\Program Files\Steinberg\Cubase SX\Components") is used for components tightly bound to the application. No other application should use it.</li>
<li>Components that are shared between all <a href="http://www.steinberg.net" target="_blank">Steinberg</a> hosts are located at:<ul>
<li>Win: "/Program Files/Common Files/Steinberg/shared components"</li>
<li>Mac: "/Library/Application Support/Steinberg/Components/"</li>
</ul>
</li>
<li>For special purpose plug-in types, additional locations can be defined. Please refer to the corresponding documentation to find out if additional folders are used and where to find them. <br />
<br />
</li>
</ul>
<h2><a class="anchor" id="Categories"></a>
Categories</h2>
<p>Any class that the factory can create is assigned to a category. It is this category that tells the host the purpose of the class (and gives a hint of which interfaces it might implement). <br />
 A class is also described with a name and it has a unique id.</p><ul>
<li>For example, the category for import/export filters is <b>"Project Filter"</b> and for VST 3 audio plug-ins <b>"Audio Module Class"</b>.</li>
<li>"Service" is a special category. The purpose of a class of this category is completely unknown to the host. It is be loaded automatically during program start (provided that the user did not deactivate it).</li>
<li>Since the factory can create any number of classes, one component library can contain multiple components of any type. <br />
<br />
</li>
</ul>
<h2><a class="anchor" id="IPluginBase"></a>
IPluginBase</h2>
<p>The entry-point interface for any component class is <a class="el" href="classSteinberg_1_1IPluginBase.html" title="Basic interface to a plug-in component: IPluginBase.">Steinberg::IPluginBase</a>. The host uses this interface to initialize and to terminate the plug-in component. When the host initializes the plug-in, it passes a so called context. This context contains any interface to the host that the plug-in will need to work. <br />
<br />
</p>
<h2><a class="anchor" id="purpose"></a>
Purpose-specific interfaces</h2>
<p>Each plug-in category (VST 3 Effects, Project import/export Filters, Audio Codecs, etc...) defines its own set of purpose-specific interfaces. These are not part of the basic VST-MA layer. <br />
<br />
</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="loadPlugin.html">How the host will load a plug-in</a> <br />
<br />
</dd></dl>
<h1><a class="anchor" id="Unicode"></a>
Unicode</h1>
<p>Beginning with version 5 of Cubase and Nuendo, the internal structure of the host was modified to better support internationalization. Therefore, string handling was changed to utilize <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> strings whenever strings are passed around. As a consequence, all the interfaces to plug-ins have changed from using ASCI to Unicode strings for call and return parameters. So in turn, all plug-in must be adapted to support Unicode. This has major consequences in that:</p><ul>
<li>Unicode hosts (Cubase 5 or later) will only work with Unicode plug-ins. When loading a plug-in, a Unicode host checks the plug-in's type and will not load any non-Unicode plug-ins. <br />
</li>
<li>Unicode plug-ins will <b>not</b> load in non-Unicode hosts. When loading a Unicode plug-in requests information from the host and will not load, if no Unicode host is detected. Therefore, if a plug-in is supposed to work with both older and newer hosts, it is best to provide two versions of the plug-in. <br />
<br />
</li>
</ul>
<h2><a class="anchor" id="plugunicode"></a>
Plug-ins for Unicode hosts</h2>
<p>Writing plug-ins that are supposed to work only with Unicode hosts is easy. Use a current version of this SDK and develop a plug-in as usual. Make sure that you only ever pass Unicode <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> strings to interfaces that have strings as call parameters and also be prepared that strings returned by these interfaces are always <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>. Therefore, to make things easier, it is recommended that Unicode strings are used throughout the plug-in's implementation, in order to avoid back and forth conversions. Also, use the Steinberg::String and Steinberg::ConstString classes from the Base module, they have been designed to work universally on both Mac and Win. <br />
<br />
</p>
<h2><a class="anchor" id="migrating"></a>
Migrating from non-Unicode to Unicode</h2>
<p>In <a href="http://www.steinberg.net" target="_blank">Steinberg</a> SDKs released before Cubase 5 the interface functions were using pointers of type <code> char </code> for passing strings to and from the host. These have been changed now to using <a class="el" href="namespaceSteinberg.html">Steinberg</a>'s defined type <code> tchar </code> which is equivalent to <code> char16 </code>, i.e. 16 bit character. In theory, there are many ways for representing 16 bits characters, but we chose to use the industry standard <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a>, so strings are expected to be encoded in <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>. <br />
Accordingly, also the implementation of a plug-in needs to be adapted to deal correctly with Unicode encoded strings, as well as only ever passing Unicode strings to the host. <br />
<br />
<b>Technical note</b>: Changing a function from using 8 bit to 16 bit character pointers may seem as only a minor modification, but in interface design this is a major intrusion, because an interface is a contract to the outside world that is never to be changed. Therefore, classes that are changed to use Unicode strings are distinguished and also receive a new unique class ID. <br />
<br />
</p>
<h2><a class="anchor" id="backward"></a>
SDK backward compatibility</h2>
<p>Even with the current SDK it is still possible to develop non-Unicode plug-ins. In the file <a href="../../pluginterfaces/base/ftypes.h">pluginterfaces/base/ftypes.h</a>, the line "#define UNICODE_OFF" is commented out, by uncommenting it you can revert all interfaces to using single byte ASCII strings. Alternatively you can also specify UNICODE_OFF as a preprocessor definition in your project file.<br />
Also, the plug-in's factory info now does not define the Unicode flag anymore, so a Unicode host sees the compiled plug-in as non-Unicode. Also, when reverting to single byte strings the plug-in's implementation also has to be changed to behave correctly. <br />
<br />
<b>Technical note</b>: When undefining Unicode, the class IDs also revert to the old ones. <br />
<br />
</p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<html>
    <head>
	    <title>Empty</title>
	    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	    <meta name="Author" content="Steinberg">
    </head>
    <body>
    <br/>
    <hr width="100%" size="2" align="left" />
    <div align=right>
        Copyright &copy;2020 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
        All Rights Reserved. This documentation is under this <a href="http://www.steinberg.net/sdklicenses" target="_blank"><u>license</u></a>.
    </div>
</body>
</html>
